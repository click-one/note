# 布隆过滤器

比如我们在使用新闻客户端看新闻时，它会给我们不停地推荐新的内容，它每次推荐时要去重，去掉那些已经看过的内容该如何实现？

或许可以将用户的浏览记录都放在再数据库中，为了更高效，可以放在缓存中。但随着时间增粘，数据量大，必然性能会越来越差。

这时候，布隆过滤器就可以派上用场了，在空间上还能节省90%以上，只是有那么一点不准确，也就是有一定的误判率。

## 布隆过滤器是什么？

布隆过滤器可以理解为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。 当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。

套在上面的使用场景中，布隆过滤器能准确过滤掉那些已经看过的内容，那些没有看过的新内容，它也会过滤掉极小一部分 \(误判\)，但是绝大多数新内容它都能准确识别。这样就可以完全保证推荐给用户的内容都是无重复的。 

## 布隆**过滤器基本使用** 

布隆过滤器有二个基本指令，bf.add 添加元素，bf.exists 查询元素是否存在，它的用法和 set 集合的 sadd 和 sismember 差不多。注意 bf.add 只能一次添加一个元素，如果想要一次添加多个，就需要用到 bf.madd 指令。同样如果需要一次查询多个元素是否存在，就需要用到 bf.mexists 指令。 

```text
127.0.0.1:6379> bf.add codehole user1
(integer) 1
127.0.0.1:6379> bf.add codehole user2
(integer) 1
127.0.0.1:6379> bf.add codehole user3
(integer) 1
127.0.0.1:6379> bf.exists codehole user1
(integer) 1
127.0.0.1:6379> bf.exists codehole user2
(integer) 1
127.0.0.1:6379> bf.exists codehole user3
(integer) 1
127.0.0.1:6379> bf.exists codehole user4
(integer) 0
127.0.0.1:6379> bf.madd codehole user4 user5 user6
1) (integer) 1
2) (integer) 1
3) (integer) 1
127.0.0.1:6379> bf.mexists codehole user4 user5 user6 user7
1) (integer) 1
2) (integer) 1
3) (integer) 1
4) (integer) 0
```

当数据量比较小时，还是比较准确的。

布隆过滤器有三个参数

* key  
* error\_rate 可接受的错误率    错误率越低，需要的空间则越大。
* initial\_size 预计放入的实际元素的数量，当实际放入的元素数量超过这个值，则误判率会上升。

## 注意事项

布隆过滤器的initial\_size估计的过大，会浪费存储空间，估计的过小，就会影响准确率，用户在使用之前一定要尽可能地精确估计好元素数量，还需要加上一定的冗余空间以避免实际元素可能会意外高出估计值很多。 

布隆过滤器的error\_rate越小，需要的存储空间就越大，对于不需要过于精确的场合，error\_rate设置稍大一点也无伤大雅。比如在新闻去重上而言，误判率高一点只会让小部分文章不能让合适的人看到，文章的整体阅读量不会因为这点误判率就带来巨大的改变。 

## 布隆过滤器使用的原理

![](../../.gitbook/assets/image%20%283%29.png)

每个布隆过滤器对应到 Redis 的数据结构里面就是一个大型的位数组和几个不一样的无偏 hash 函数。所谓无偏就是能够把元素的 hash 值算得比较均匀。 

向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。 

向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都位 1，只要有一个位为 0，那么说明布隆过滤器中这个 key 不存在。如果都是 1，这并不能说明这个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。

## 布隆过滤器空间占用设计 

布隆过滤器有两个参数，第一个是预计元素的数量 n，第二个是错误率 f。公式根据这两个输入得到两个输出，第一个输出是位数组的长度 l，也就是需要的存储空间大小 \(bit\)，第二个输出是 hash 函数的最佳数量 k。hash 函数的数量也会直接影响到错误率，最佳的数量会有最低的错误率。 

* k=0.7\*\(l/n\) \# 约等于 
* f=0.6185^\(l/n\) \# ^ 表示次方计算，也就是 math.pow 

从公式中可以看出 

1、位数组相对越长 \(l/n\)，错误率 f 越低，这个和直观上理解是一致的 

2、位数组相对越长 \(l/n\)，hash 函数需要的最佳数量也越多，影响计算效率 

3、当一个元素平均需要 1 个字节 \(8bit\) 的指纹空间时 \(l/n=8\)，错误率大约为 2% 

4、错误率为 10%，一个元素需要的平均指纹空间为 4.792 个 bit，大约为 5bit 

5、错误率为 1%，一个元素需要的平均指纹空间为 9.585 个 bit，大约为 10bit 

6、错误率为 0.1%，一个元素需要的平均指纹空间为 14.377 个 bit，大约为 15bit 

你也许会想，如果一个元素需要占据 15 个 bit，那相对 set 集合的空间优势是不是就没有那么明显了？这里需要明确的是，set 中会存储每个元素的内容，而布隆过滤器仅仅存储元素的指纹。元素的内容大小就是字符串的长度，它一般会有多个字节，甚至是几十个上百个字节，每个元素本身还需要一个指针被 set 集合来引用，这个指针又会占去 4 个字节或 8 个字节，取决于系统是 32bit 还是 64bit。而指纹空间只有接近 2 个字节，所以布隆过滤器的空间优势还是非常明显的。 

在线布隆过滤器计算器

## **实际元素超出时**，**误判率会怎样变化** 

1、错误率为 10% 时，倍数比为 2 时，错误率就会升至接近 40%**。**

2、错误率为 1% 时，倍数比为 2 时，错误率升至 15%。

3、错误率为 0.1%，倍数比为 2 时，错误率升至 5%。



