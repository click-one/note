# 线程IO

## redis都是单线程的，为什么能这么快？

* 所有指令都是基于内存的
* io多路复用
* 高效的数据结构

在看redis为什么能这么快，先了解下操作系统中的常见io模型

## IO模型

网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作。对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：

* 通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。
* 把数据从内核缓冲区复制到应用进程缓冲区。

### 阻塞式IO

![](../../.gitbook/assets/image%20%2817%29.png)

在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。

阻塞式io的两个阶段都是阻塞式的，只有等到两个阶段都完成时，recvfrom才会返回，在此期间该线程什么事也做不了，在此期间只能漫长的等待。

### 非阻塞式IO

![](../../.gitbook/assets/image%20%2812%29.png)

在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个信息。

进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。

**非阻塞方式相比阻塞方式：** 

* 优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。 
* 缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。

### IO 多路复用



